name: Collect service logs

on:
  workflow_dispatch:

permissions:
  contents: write

jobs:
  collect-logs:
    name: Collect Docker service logs
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Collect logs from server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.LIGHTSAIL_HOST }}
          username: deploy
          key: ${{ secrets.LIGHTSAIL_SSH_KEY }}
          script: |
            set -e

            APP_NAME="watch-party"
            # Try multiple possible application directories
            if [ -d "/srv/$APP_NAME" ]; then
              APP_DIR="/srv/$APP_NAME"
            elif [ -d "$HOME/watch-party" ]; then
              APP_DIR="$HOME/watch-party"
            else
              echo "‚ùå Application directory not found"
              echo "Tried: /srv/$APP_NAME and $HOME/watch-party"
              exit 1
            fi

            echo "üìÅ Using application directory: $APP_DIR"
            cd "$APP_DIR"

            # Create/clear logs directory in the project
            LOGS_DIR="$APP_DIR/logs"
            echo "üìÅ Preparing logs directory: $LOGS_DIR"
            rm -rf "$LOGS_DIR"
            mkdir -p "$LOGS_DIR"

            # Determine docker compose command
            if command -v docker-compose &> /dev/null; then
              DOCKER_COMPOSE="docker-compose"
            elif docker compose version &> /dev/null 2>&1; then
              DOCKER_COMPOSE="docker compose"
            else
              echo "‚ùå Neither docker-compose nor docker compose found"
              exit 1
            fi

            echo "üîç Using Docker Compose command: $DOCKER_COMPOSE"

            # Get list of services
            echo "üîç Checking for running services..."
            if ! $DOCKER_COMPOSE ps > /dev/null 2>&1; then
              echo "‚ùå Unable to check Docker Compose services"
              echo "This might mean the application is not running"
              exit 1
            fi

            # Get all services (running and stopped)
            all_services=$($DOCKER_COMPOSE ps --services 2>/dev/null \
              || echo "")
            running_services=$($DOCKER_COMPOSE ps --services \
              --filter "status=running" 2>/dev/null || echo "")

            if [ -z "$all_services" ]; then
              echo "‚ùå No services found in docker-compose project"
              echo "Docker Compose status:"
              $DOCKER_COMPOSE ps || true
              exit 1
            fi

            echo "üìã All services: $all_services"
            echo "‚úÖ Running services: $running_services"

            # Collect logs from all services (including stopped ones)
            echo "üîÑ Starting log collection for services..."
            for service in $all_services; do
              echo "üìù Collecting logs for service: $service"
              log_file="$LOGS_DIR/${service}.log"

              # Get logs with timestamps, limit to last 1000 lines
              # Try docker compose logs first
              if $DOCKER_COMPOSE logs --no-color --timestamps --tail=1000 "$service" > "$log_file" 2>&1; then
                # Check if file has content
                if [ -s "$log_file" ]; then
                  lines=$(wc -l < "$log_file")
                  echo "‚úÖ Collected logs for $service ($lines lines)"
                else
                  echo "‚ö†Ô∏è  Log file for $service is empty"
                fi
              else
                echo "‚ö†Ô∏è  docker compose logs failed for $service"
                # Try using docker logs directly as fallback
                container_name=$($DOCKER_COMPOSE ps -q "$service" 2>/dev/null)
                if [ -n "$container_name" ]; then
                  echo "üîÑ Trying docker logs directly for container $container_name"
                  if docker logs --timestamps --tail=1000 "$container_name" > "$log_file" 2>&1; then
                    if [ -s "$log_file" ]; then
                      lines=$(wc -l < "$log_file")
                      echo "‚úÖ Collected logs via docker logs for $service ($lines lines)"
                    else
                      echo "‚ö†Ô∏è  Docker logs returned empty for $service"
                      echo "No logs available for service $service" > "$log_file"
                    fi
                  else
                    echo "‚ùå Both docker compose logs and docker logs failed for $service"
                    echo "Error: Could not collect logs for $service" > "$log_file"
                  fi
                else
                  echo "‚ùå No container found for service $service"
                  echo "Error: No container found for service $service" > "$log_file"
                fi
              fi
              
              # Verify file was created
              if [ -f "$log_file" ]; then
                echo "‚úì Log file created: $log_file ($(wc -l < "$log_file" 2>/dev/null || echo 0) lines)"
              else
                echo "‚ùå Failed to create log file: $log_file"
                # Force create an error file
                echo "Error: Log file creation failed" > "$log_file" || echo "‚ùå Cannot write to $log_file"
              fi
            done
            
            echo "‚úÖ Log collection loop completed"
            echo "üìã Files in logs directory:"
            ls -lah "$LOGS_DIR" || echo "‚ùå Cannot list logs directory"
            
            # Check for additional watch-party containers not in compose services
            echo "üîç Checking for additional watch-party containers..."
            additional_containers=$(docker ps -a --format '{{.Names}}' | grep -i 'watch-party' || echo "")
            
            if [ -n "$additional_containers" ]; then
              echo "üìã Found additional containers: $additional_containers"
              for container in $additional_containers; do
                # Extract service name from container name (e.g., watch-party-frontend-1 -> frontend)
                service_name=$(echo "$container" | sed 's/watch-party-//' | sed 's/-[0-9]*$//')
                log_file="$LOGS_DIR/${service_name}.log"
                
                # Check if we already collected logs for this service
                if [ -f "$log_file" ]; then
                  echo "‚è© Skipping $service_name - already collected"
                else
                  echo "üìù Collecting logs from additional container: $container (service: $service_name)"
                  if docker logs --timestamps --tail=1000 "$container" > "$log_file" 2>&1; then
                    if [ -s "$log_file" ]; then
                      lines=$(wc -l < "$log_file")
                      echo "‚úÖ Collected logs for $service_name from container ($lines lines)"
                    else
                      echo "‚ö†Ô∏è  Logs empty for $service_name"
                      echo "No logs available for $service_name (container: $container)" > "$log_file"
                    fi
                  else
                    echo "‚ùå Failed to collect logs for $service_name"
                    echo "Error: Could not collect logs for $service_name (container: $container)" > "$log_file"
                  fi
                fi
              done
            else
              echo "‚ÑπÔ∏è  No additional watch-party containers found"
            fi

            # Also collect docker compose ps output
            echo "üìù Collecting container status..."
            $DOCKER_COMPOSE ps > "$LOGS_DIR/docker-compose-ps.txt" \
              2>&1 || true

            # Collect docker ps -a output
            echo "üìù Collecting all container statuses..."
            docker ps -a > "$LOGS_DIR/docker-ps-all.txt" 2>&1 || true

            # Create a summary file
            echo "üìù Creating summary file..."
            cat > "$LOGS_DIR/summary.txt" << 'SUMMARY_EOF'
            Log Collection Summary
            ======================
            SUMMARY_EOF

            # Append dynamic content
            {
              echo "Date: $(date)"
              echo "Server: $(hostname)"
              echo "Application Directory: $APP_DIR"
              echo ""
              echo "All Services: $all_services"
              echo "Running Services: $running_services"
              echo ""
              echo "Docker Compose Version:"
              $DOCKER_COMPOSE version 2>&1 || echo "Version check failed"
              echo ""
              echo "Docker Version:"
              docker --version 2>&1 || echo "Version check failed"
            } >> "$LOGS_DIR/summary.txt"

            echo "‚úÖ Logs collected successfully in $LOGS_DIR"
            echo "üìã Log files created:"
            ls -lh "$LOGS_DIR"

      - name: Download logs from server
        run: |
          set -e

          # Setup SSH key
          mkdir -p "$HOME/.ssh"
          echo "${{ secrets.LIGHTSAIL_SSH_KEY }}" > "$HOME/.ssh/lightsail_key"
          chmod 600 "$HOME/.ssh/lightsail_key"

          # Add server to known hosts
          HOST="${{ secrets.LIGHTSAIL_HOST }}"
          ssh-keyscan -H "$HOST" >> "$HOME/.ssh/known_hosts"

          # Determine application directory on server
          APP_DIR=$(ssh -i "$HOME/.ssh/lightsail_key" deploy@"$HOST" \
            'if [ -d "/srv/watch-party" ]; then echo "/srv/watch-party"; elif [ -d "$HOME/watch-party" ]; then echo "$HOME/watch-party"; fi' \
            2>/dev/null)

          if [ -z "$APP_DIR" ]; then
            echo "‚ùå Could not determine application directory on server"
            exit 1
          fi

          echo "üì• Downloading logs from $APP_DIR/logs/"

          # Remove existing local logs directory
          rm -rf logs

          # Download the entire logs directory
          if scp -r -i "$HOME/.ssh/lightsail_key" \
            "deploy@$HOST:$APP_DIR/logs" .; then
            echo "‚úÖ Downloaded logs directory"

            echo "üìã Downloaded log files:"
            ls -lh logs/
          else
            echo "‚ùå Failed to download logs directory"
            exit 1
          fi

          # Clean up SSH key
          rm -f "$HOME/.ssh/lightsail_key"

      - name: Commit and push logs
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Add logs directory
          git add logs/

          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "‚ÑπÔ∏è  No changes to commit"
          else
            git commit -m "Update service logs [skip ci]"
            git push
            echo "‚úÖ Logs committed and pushed to repository"
          fi
