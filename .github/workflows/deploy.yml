name: Deploy to Lightsail

on:
  push:
    branches: [ "master", "main" ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - uses: actions/checkout@v4

      - name: Deploy over SSH
        uses: appleboy/ssh-action@v1.0.3
        timeout-minutes: 14
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        with:
          host: ${{ secrets.LIGHTSAIL_HOST }}
          username: deploy
          key: ${{ secrets.LIGHTSAIL_SSH_KEY }}
          envs: AWS_ACCESS_KEY_ID,AWS_SECRET_ACCESS_KEY
          script: |
            set -e
            APP_NAME=watch-party
            APP_DIR=/srv/$APP_NAME
            
            # Clone or update repo
            if [ ! -d "$APP_DIR" ]; then
              git clone https://github.com/EL-HOUSS-BRAHIM/watch-party.git $APP_DIR
              cd $APP_DIR
            else
              cd $APP_DIR
              git fetch origin
              git reset --hard origin/master
            fi
            
            # Setup environment files if they don't exist
            if [ ! -f "$APP_DIR/backend/.env" ]; then
              cp backend/.env.example backend/.env
              echo "‚ö†Ô∏è  Created backend/.env from example"
              echo "‚ö†Ô∏è  IMPORTANT: Update backend/.env with your AWS credentials:"
              echo "   - Database password for RDS PostgreSQL"
              echo "   - Redis auth token for ElastiCache"
              echo "   - Other service credentials (email, OAuth, etc.)"
            fi
            
            if [ ! -f "$APP_DIR/frontend/.env.local" ]; then
              cp frontend/.env.example frontend/.env.local
              echo "‚úÖ Created frontend/.env.local with correct API URLs"
            fi
            
            # Configure AWS CLI (required for AWS external services)
            if ! command -v aws &> /dev/null; then
              echo "üì¶ Installing AWS CLI..."
              curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
              unzip -o -q awscliv2.zip
              
              # Install AWS CLI in user's home directory (no sudo needed)
              echo "Installing AWS CLI for current user (deploy)..."
              ./aws/install --install-dir $HOME/aws-cli --bin-dir $HOME/aws-cli-bin --update
              
              # Add to PATH for this session
              export PATH="$HOME/aws-cli-bin:$PATH"
              echo 'export PATH="$HOME/aws-cli-bin:$PATH"' >> ~/.bashrc
              
              rm -rf aws awscliv2.zip
              echo "‚úÖ AWS CLI installed: $(aws --version)"
            else
              echo "‚úÖ AWS CLI already installed: $(aws --version)"
            fi
            
            # Configure AWS credentials and region for Secrets Manager access
            mkdir -p ~/.aws
            cat > ~/.aws/config << EOF
            [default]
            region = eu-west-3
            output = json
            EOF
            
            # Configure AWS credentials if provided via environment variables
            # (these would be set from GitHub Actions secrets)
            if [ -n "${AWS_ACCESS_KEY_ID:-}" ] && [ -n "${AWS_SECRET_ACCESS_KEY:-}" ]; then
              echo "üîß Configuring AWS credentials from environment variables..."
              cat > ~/.aws/credentials << EOF
            [default]
            aws_access_key_id = ${AWS_ACCESS_KEY_ID}
            aws_secret_access_key = ${AWS_SECRET_ACCESS_KEY}
            EOF
              chmod 600 ~/.aws/credentials
            else
              echo "üîß Using IAM role for AWS access (no credentials file needed)"
            fi
            
            # Test AWS connectivity
            echo "üîç Testing AWS connectivity..."
            if ! aws sts get-caller-identity > /dev/null 2>&1; then
              echo "‚ùå AWS configuration failed."
              echo "   Either configure AWS credentials in GitHub secrets (AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY)"
              echo "   OR ensure IAM role MyAppRole is attached to this server."
              exit 1
            fi
            echo "‚úÖ AWS connectivity confirmed"
            
            # Test Secrets Manager access (required for app configuration)
            echo "üîç Testing Secrets Manager access..."
            if aws secretsmanager list-secrets --region eu-west-3 > /dev/null 2>&1; then
              echo "‚úÖ AWS Secrets Manager access confirmed"
            else
              echo "‚ö†Ô∏è  Secrets Manager access test failed - check permissions"
              echo "   The app needs access to secrets like 'all-in-one-credentials'"
            fi
            
            # Build and deploy with Docker Compose (uses external AWS services)
            echo "üèóÔ∏è  Building Docker images with optimizations..."
            
            # Enable Docker BuildKit for better caching and parallel builds
            export DOCKER_BUILDKIT=1
            export COMPOSE_DOCKER_CLI_BUILD=1
            export BUILDKIT_PROGRESS=plain
            
            # Clean up old containers first
            docker-compose down --remove-orphans || true
            
            # Build images in parallel with optimized caching
            echo "üì¶ Building images in parallel..."
            timeout 1200 docker-compose build --parallel --build-arg BUILDKIT_INLINE_CACHE=1 || {
              echo "‚ö†Ô∏è Parallel build failed, trying sequential build..."
              
              # Build backend first (faster and required by others)
              echo "üì¶ Building backend image..."
              if ! timeout 600 docker-compose build backend; then
                echo "‚ùå Backend build failed"
                exit 1
              fi
              
              # Build frontend with optimized settings and compatibility timeout
              echo "üì¶ Building frontend image..."
              if ! timeout 1200 docker-compose build frontend \
                --build-arg NODE_OPTIONS="--max-old-space-size=2048"; then
                echo "‚ùå Frontend build failed"
                exit 1
              fi
            }
            
            echo "‚úÖ All images built successfully"
            
            # Start services in optimized stages
            echo "üöÄ Starting backend service..."
            docker-compose up -d backend
            
            # Reduced wait time with smarter health checking
            echo "‚è≥ Waiting for backend to be ready..."
            for i in {1..20}; do
              if docker-compose exec -T backend python manage.py check --deploy > /dev/null 2>&1; then
                echo "‚úÖ Backend is ready"
                break
              elif [ $i -eq 20 ]; then
                echo "‚ùå Backend failed to start properly"
                docker-compose logs --tail=30 backend
                exit 1
              else
                echo "‚è≥ Waiting for backend... ($i/20)"
                sleep 3
              fi
            done
            
            echo "üöÄ Starting all services..."
            docker-compose up -d
            
            # Optimized health checking with shorter intervals
            echo "‚è≥ Waiting for services to be ready..."
            sleep 15
            
            # Test backend health with optimized retry logic
            echo "üè• Testing backend health..."
            for i in {1..12}; do
              if curl -f -s http://localhost:8000/health/ > /dev/null 2>&1; then
                echo "‚úÖ Backend is healthy"
                break
              elif [ $i -eq 12 ]; then
                echo "‚ùå Backend health check failed after 6 minutes"
                echo "üìã Backend logs:"
                docker-compose logs --tail=30 backend
                echo "üìã Container status:"
                docker-compose ps
                exit 1
              else
                echo "‚è≥ Backend health check... ($i/12)"
                sleep 30
              fi
            done
            
            # Test frontend health with reduced wait time
            echo "üè• Testing frontend health..."
            for i in {1..8}; do
              if curl -f -s http://localhost:3000 > /dev/null 2>&1; then
                echo "‚úÖ Frontend is healthy"
                break
              elif [ $i -eq 8 ]; then
                echo "‚ùå Frontend health check failed"
                echo "üìã Frontend logs:"
                docker-compose logs --tail=30 frontend
                exit 1
              else
                echo "‚è≥ Frontend health check... ($i/8)"
                sleep 10
              fi
            done
            
            # Run initial setup if this is first deployment
            if docker-compose exec -T backend python manage.py showmigrations --plan | grep -q "\[ \]"; then
              echo "üîß Running initial Django setup..."
              if ! docker-compose exec -T backend python manage.py migrate; then
                echo "‚ùå Migration failed. Check database connectivity:"
                echo "   - Verify RDS PostgreSQL is accessible"
                echo "   - Check database credentials in backend/.env"
                docker-compose logs backend
                exit 1
              fi
              docker-compose exec -T backend python manage.py collectstatic --noinput
            fi
            
            # Final health check
            echo "üè• Final health check..."
            if curl -f http://localhost:8000/health/ > /dev/null 2>&1; then
              echo "üéâ Deployment successful!"
              echo "   Frontend: http://${{ secrets.LIGHTSAIL_HOST }}/"
              echo "   Backend API: http://${{ secrets.LIGHTSAIL_HOST }}/api/"
            else
              echo "‚ùå Final health check failed"
              docker-compose logs --tail=20 backend
              exit 1
            fi
            
            # Cleanup
            docker system prune -f
