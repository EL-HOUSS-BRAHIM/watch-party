name: Deploy to Lightsail

on:
  push:
    branches: [ "master", "main" ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - uses: actions/checkout@v4

      - name: Deploy over SSH
        uses: appleboy/ssh-action@v1.0.3
        timeout-minutes: 14
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          SSL_ORIGIN: ${{ secrets.SSL_ORIGIN }}
          SSL_PRIVATE: ${{ secrets.SSL_PRIVATE }}
        with:
          host: ${{ secrets.LIGHTSAIL_HOST }}
          username: deploy
          key: ${{ secrets.LIGHTSAIL_SSH_KEY }}
          envs: AWS_ACCESS_KEY_ID,AWS_SECRET_ACCESS_KEY,SSL_ORIGIN,SSL_PRIVATE
          script: |
            set -e
            APP_NAME=watch-party
            APP_DIR=/srv/$APP_NAME
            
            # Clone or update repo
            if [ ! -d "$APP_DIR" ]; then
              git clone https://github.com/EL-HOUSS-BRAHIM/watch-party.git $APP_DIR
              cd $APP_DIR
            else
              cd $APP_DIR
              git fetch origin
              git reset --hard origin/master
            fi
            
            # Ensure the deploy user has proper access to the application directory
            echo "üîß Setting up directory permissions..."
            if [ "$(stat -c '%U' $APP_DIR 2>/dev/null)" != "deploy" ]; then
              echo "‚ö†Ô∏è  Application directory not owned by deploy user"
              echo "   Attempting to fix permissions..."
              if sudo chown -R deploy:deploy $APP_DIR 2>/dev/null; then
                echo "‚úÖ Fixed directory ownership"
              else
                echo "‚ùå Cannot change ownership. Using alternative approach..."
                # Create a new directory in home instead
                OLD_APP_DIR="$APP_DIR"
                APP_DIR="$HOME/watch-party"
                echo "üìÅ Switching to alternative directory: $APP_DIR"
                
                # Copy or clone to the new location
                if [ -d "$OLD_APP_DIR" ]; then
                  echo "üìã Copying application from $OLD_APP_DIR to $APP_DIR"
                  rm -rf "$APP_DIR" 2>/dev/null || true
                  cp -r "$OLD_APP_DIR" "$APP_DIR"
                  cd "$APP_DIR"
                  # Ensure we have the latest code
                  git fetch origin 2>/dev/null || true
                  git reset --hard origin/master 2>/dev/null || true
                else
                  if [ ! -d "$APP_DIR" ]; then
                    git clone https://github.com/EL-HOUSS-BRAHIM/watch-party.git $APP_DIR
                  else
                    cd $APP_DIR
                    git fetch origin
                    git reset --hard origin/master
                  fi
                  cd $APP_DIR
                fi
                echo "‚úÖ Using writable directory: $APP_DIR"
              fi
            else
              echo "‚úÖ Directory ownership is correct"
            fi
            
            # Generate production environment files from templates
            echo "üîß Setting up production environment files..."
            
            # Generate backend .env for production
            echo "üìù Creating backend/.env for production..."
            cat > backend/.env << 'BACKEND_ENV'
            # WATCH PARTY BACKEND - PRODUCTION CONFIGURATION
            DEBUG=False
            SECRET_KEY=your-super-secret-key-here-change-in-production
            DJANGO_SETTINGS_MODULE=config.settings.production
            ALLOWED_HOSTS=35.181.116.57,be-watch-party.brahim-elhouss.me,watch-party.brahim-elhouss.me,localhost,127.0.0.1
            
            # DATABASE CONFIGURATION (AWS RDS PostgreSQL)
            DATABASE_URL=postgresql://watchparty_admin:A)B8WK6~OTtE9cgxjF*ZzVRomLdG@all-in-one.cj6w0queklir.eu-west-3.rds.amazonaws.com:5432/watchparty_prod?sslmode=require
            DB_NAME=watchparty_prod
            DB_USER=watchparty_admin
            DB_PASSWORD=A)B8WK6~OTtE9cgxjF*ZzVRomLdG
            DB_HOST=all-in-one.cj6w0queklir.eu-west-3.rds.amazonaws.com
            DB_PORT=5432
            DB_SSL_MODE=require
            
            # REDIS CONFIGURATION (AWS ElastiCache Valkey - using dynamic AWS Secrets Manager)
            REDIS_HOST=master.watch-party-valkey.2muo9f.euw3.cache.amazonaws.com
            REDIS_PORT=6379
            REDIS_USE_SSL=True
            
            # SECURITY SETTINGS
            SECURE_SSL_REDIRECT=True
            SESSION_COOKIE_SECURE=True
            CSRF_COOKIE_SECURE=True
            SECURE_HSTS_SECONDS=31536000
            SECURE_HSTS_INCLUDE_SUBDOMAINS=True
            SECURE_HSTS_PRELOAD=True
            
            # AWS S3 CONFIGURATION
            USE_S3=true
            AWS_STORAGE_BUCKET_NAME=your-s3-bucket-name
            AWS_S3_REGION_NAME=eu-west-3
            
            # CORS CONFIGURATION
            CORS_ALLOWED_ORIGINS=https://watch-party.brahim-elhouss.me,https://be-watch-party.brahim-elhouss.me
            
            # ENVIRONMENT
            ENVIRONMENT=production
            
            # FEATURE FLAGS
            MAINTENANCE_MODE=False
            REGISTRATION_ENABLED=True
            GOOGLE_DRIVE_INTEGRATION_ENABLED=True
            YOUTUBE_INTEGRATION_ENABLED=True
            TWO_FACTOR_AUTH_ENABLED=True
            
            # EMAIL CONFIGURATION
            EMAIL_BACKEND=django.core.mail.backends.console.EmailBackend
            DEFAULT_FROM_EMAIL=noreply@watchparty.com
            
            # JWT AUTHENTICATION
            JWT_SECRET_KEY=your-jwt-secret-key-change-this
            JWT_REFRESH_SECRET_KEY=your-jwt-refresh-secret-key-change-this
            JWT_ACCESS_TOKEN_LIFETIME=60
            JWT_REFRESH_TOKEN_LIFETIME=7
            
            # OTHER PRODUCTION SETTINGS
            RATE_LIMIT_LOGIN=5/min
            RATE_LIMIT_API=1000/hour
            RATE_LIMIT_UPLOAD=10/hour
            BACKEND_ENV
            
            # Generate frontend .env.local for production
            echo "üìù Creating frontend/.env.local for production..."
            cat > frontend/.env.local << 'FRONTEND_ENV'
            # Production Frontend Environment Variables
            NEXT_PUBLIC_API_URL=https://be-watch-party.brahim-elhouss.me
            NEXT_PUBLIC_WS_URL=wss://be-watch-party.brahim-elhouss.me/ws
            
            # Feature Flags
            NEXT_PUBLIC_ENABLE_GOOGLE_DRIVE=true
            NEXT_PUBLIC_ENABLE_DISCORD=true
            NEXT_PUBLIC_ENABLE_ANALYTICS=true
            FRONTEND_ENV
            
            echo "‚úÖ Production environment files created"
            echo "üîç Verifying Django settings module..."
            if grep -q "DJANGO_SETTINGS_MODULE=config.settings.production" backend/.env; then
              echo "‚úÖ DJANGO_SETTINGS_MODULE correctly set to config.settings.production"
            else
              echo "‚ö†Ô∏è  Warning: DJANGO_SETTINGS_MODULE configuration issue"
            fi
            
            # Configure AWS CLI (required for AWS external services)
            if ! command -v aws &> /dev/null; then
              echo "üì¶ Installing AWS CLI..."
              curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
              unzip -o -q awscliv2.zip
              
              # Install AWS CLI in user's home directory (no sudo needed)
              echo "Installing AWS CLI for current user (deploy)..."
              ./aws/install --install-dir $HOME/aws-cli --bin-dir $HOME/aws-cli-bin --update
              
              # Add to PATH for this session
              export PATH="$HOME/aws-cli-bin:$PATH"
              echo 'export PATH="$HOME/aws-cli-bin:$PATH"' >> ~/.bashrc
              
              rm -rf aws awscliv2.zip
              echo "‚úÖ AWS CLI installed: $(aws --version)"
            else
              echo "‚úÖ AWS CLI already installed: $(aws --version)"
            fi
            
            # Configure AWS credentials and region for Secrets Manager access
            mkdir -p ~/.aws
            cat > ~/.aws/config << 'AWSCONFIG'
            [default]
            region = eu-west-3
            output = json
            AWSCONFIG
            
            # Configure AWS credentials if provided via environment variables
            # (these would be set from GitHub Actions secrets)
            if [ -n "${AWS_ACCESS_KEY_ID:-}" ] && [ -n "${AWS_SECRET_ACCESS_KEY:-}" ]; then
              echo "üîß Configuring AWS credentials from environment variables..."
              cat > ~/.aws/credentials << AWSCREDS
            [default]
            aws_access_key_id = ${AWS_ACCESS_KEY_ID}
            aws_secret_access_key = ${AWS_SECRET_ACCESS_KEY}
            AWSCREDS
              chmod 600 ~/.aws/credentials
            else
              echo "üîß Using IAM role for AWS access (no credentials file needed)"
            fi
            
            # Test AWS connectivity
            echo "üîç Testing AWS connectivity..."
            if ! aws sts get-caller-identity > /dev/null 2>&1; then
              echo "‚ùå AWS configuration failed."
              echo "   Either configure AWS credentials in GitHub secrets (AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY)"
              echo "   OR ensure IAM role MyAppRole is attached to this server."
              exit 1
            fi
            echo "‚úÖ AWS connectivity confirmed"
            
            # Test Secrets Manager access (required for app configuration)
            echo "üîç Testing Secrets Manager access..."
            if aws secretsmanager get-secret-value --secret-id all-in-one-credentials --region eu-west-3 > /dev/null 2>&1; then
              echo "‚úÖ AWS Secrets Manager access confirmed"
            else
              echo "‚ö†Ô∏è  Secrets Manager access test failed - check permissions"
              echo "   The app needs access to secrets like 'all-in-one-credentials'"
            fi
            
            # Configure SSL certificates for HTTPS
            echo "üîê Setting up SSL certificates..."
            
            # Create SSL directory in nginx/ssl (this will be mounted to nginx container)
            SSL_DIR="$APP_DIR/nginx/ssl"
            echo "üìÅ Creating SSL directory: $SSL_DIR"
            
            # Ensure the parent directories exist with proper permissions
            mkdir -p "$APP_DIR/nginx"
            mkdir -p "$SSL_DIR"
            
            # Test write permissions
            if ! touch "$SSL_DIR/.test_write" 2>/dev/null; then
              echo "‚ùå Cannot write to SSL directory: $SSL_DIR"
              echo "   Directory owner: $(stat -c '%U:%G' $SSL_DIR 2>/dev/null || echo 'unknown')"
              echo "   Directory permissions: $(stat -c '%a' $SSL_DIR 2>/dev/null || echo 'unknown')"
              echo "   Current user: $(whoami)"
              echo "   Current APP_DIR: $APP_DIR"
              
              # Try to fix permissions one more time
              if [ "$APP_DIR" != "$HOME/watch-party" ]; then
                echo "üîÑ Attempting to switch to home directory as final fallback..."
                OLD_APP_DIR="$APP_DIR"
                APP_DIR="$HOME/watch-party"
                
                # Copy application to home directory
                if [ -d "$OLD_APP_DIR" ]; then
                  rm -rf "$APP_DIR" 2>/dev/null || true
                  cp -r "$OLD_APP_DIR" "$APP_DIR"
                  cd "$APP_DIR"
                else
                  git clone https://github.com/EL-HOUSS-BRAHIM/watch-party.git "$APP_DIR"
                  cd "$APP_DIR"
                fi
                
                # Update SSL_DIR to new location
                SSL_DIR="$APP_DIR/nginx/ssl"
                mkdir -p "$SSL_DIR"
                echo "üìÅ Updated SSL directory: $SSL_DIR"
                
                # Test write permissions again
                if ! touch "$SSL_DIR/.test_write" 2>/dev/null; then
                  echo "‚ùå Still cannot write to SSL directory, this is a critical error"
                  exit 1
                fi
              else
                echo "‚ùå Already using home directory but still cannot write, this is a critical error"
                exit 1
              fi
            fi
            
            # Remove test file
            rm -f "$SSL_DIR/.test_write"
            echo "‚úÖ SSL directory is writable"
            
            # Check if SSL certificates already exist
            if [ -f "$SSL_DIR/origin.pem" ] && [ -f "$SSL_DIR/private.key" ]; then
              echo "‚úÖ SSL certificates already exist"
            else
              echo "üìù Creating SSL certificates from GitHub secrets..."
              
              # Create origin certificate from SSL_ORIGIN secret
              if [ -n "${SSL_ORIGIN:-}" ]; then
                if echo "$SSL_ORIGIN" > "$SSL_DIR/origin.pem" 2>/dev/null; then
                  chmod 644 "$SSL_DIR/origin.pem"
                  echo "‚úÖ SSL origin certificate created at $SSL_DIR/origin.pem"
                else
                  echo "‚ùå Failed to create SSL origin certificate"
                  exit 1
                fi
              else
                echo "‚ö†Ô∏è  SSL_ORIGIN secret not provided - HTTPS will not work"
              fi
              
              # Create private key from SSL_PRIVATE secret
              if [ -n "${SSL_PRIVATE:-}" ]; then
                if echo "$SSL_PRIVATE" > "$SSL_DIR/private.key" 2>/dev/null; then
                  chmod 600 "$SSL_DIR/private.key"
                  echo "‚úÖ SSL private key created at $SSL_DIR/private.key"
                else
                  echo "‚ùå Failed to create SSL private key"
                  exit 1
                fi
              else
                echo "‚ö†Ô∏è  SSL_PRIVATE secret not provided - HTTPS will not work"
              fi
              
              # Verify SSL certificate files
              if [ -f "$SSL_DIR/origin.pem" ] && [ -f "$SSL_DIR/private.key" ]; then
                echo "üîç Verifying SSL certificate..."
                if openssl x509 -in "$SSL_DIR/origin.pem" -noout -text > /dev/null 2>&1; then
                  echo "‚úÖ SSL certificate is valid"
                else
                  echo "‚ö†Ô∏è  SSL certificate validation failed"
                fi
              fi
            fi
            
            # Build and deploy with Docker Compose (uses external AWS services)
            echo "üèóÔ∏è  Building Docker images with optimizations..."
            
            # Enable Docker BuildKit for better caching and parallel builds
            export DOCKER_BUILDKIT=1
            export COMPOSE_DOCKER_CLI_BUILD=1
            export BUILDKIT_PROGRESS=plain
            
            # Clean up old containers first
            docker-compose down --remove-orphans || true
            
            # Build images in parallel with optimized caching
            echo "üì¶ Building images in parallel..."
            export DOCKER_BUILDKIT=1
            export COMPOSE_DOCKER_CLI_BUILD=1
            export BUILDKIT_PROGRESS=plain
            # Set environment variable to skip AWS calls during build
            export SKIP_AWS_DURING_BUILD=1
            
            timeout 1200 docker-compose build --parallel --build-arg BUILDKIT_INLINE_CACHE=1 --build-arg SKIP_AWS_DURING_BUILD=1 || {
              echo "‚ö†Ô∏è Parallel build failed, trying sequential build..."
              
              # Build backend first (faster and required by others)
              echo "üì¶ Building backend image..."
              if ! timeout 600 docker-compose build backend --build-arg SKIP_AWS_DURING_BUILD=1; then
                echo "‚ùå Backend build failed"
                exit 1
              fi
              
              # Build frontend with optimized settings and compatibility timeout
              echo "üì¶ Building frontend image..."
              if ! timeout 1200 docker-compose build frontend \
                --build-arg NODE_OPTIONS="--max-old-space-size=2048" \
                --build-arg SKIP_AWS_DURING_BUILD=1; then
                echo "‚ùå Frontend build failed"
                exit 1
              fi
            }
            
            echo "‚úÖ All images built successfully"
            
            # Ensure firewall allows HTTP and HTTPS traffic
            echo "üî• Configuring firewall for web traffic..."
            if command -v ufw >/dev/null 2>&1; then
              echo "üìã Current UFW status:"
              sudo ufw status 2>/dev/null || echo "UFW not available or no sudo access"
              
              # Try to allow HTTP and HTTPS (will only work if user has sudo)
              if sudo ufw allow 80/tcp 2>/dev/null; then
                echo "‚úÖ Allowed HTTP traffic (port 80)"
              else
                echo "‚ö†Ô∏è  Could not configure UFW rule for port 80 (check manually)"
              fi
              
              if sudo ufw allow 443/tcp 2>/dev/null; then
                echo "‚úÖ Allowed HTTPS traffic (port 443)"
              else
                echo "‚ö†Ô∏è  Could not configure UFW rule for port 443 (check manually)"
              fi
            fi
            
            # Check if AWS security groups or other cloud firewalls might be blocking
            echo "üìã Cloud firewall reminder:"
            echo "   Make sure your AWS Lightsail instance allows:"
            echo "   - HTTP traffic on port 80"
            echo "   - HTTPS traffic on port 443"
            echo "   - This can be configured in the Lightsail networking tab"
            
            # Start services in optimized stages
            echo "üöÄ Starting backend service..."
            docker-compose up -d backend
            
            # Improved backend readiness checking with multiple fallbacks
            echo "‚è≥ Waiting for backend to be ready..."
            backend_ready=false
            
            for i in {1..30}; do
              # Try multiple health check methods
              if docker-compose exec -T backend python manage.py check --deploy > /dev/null 2>&1; then
                echo "‚úÖ Backend Django checks passed"
                backend_ready=true
                break
              elif curl -f -s http://localhost:8000/health/ > /dev/null 2>&1; then
                echo "‚úÖ Backend HTTP health check passed"
                backend_ready=true
                break
              elif docker-compose exec -T backend python -c "import django; django.setup()" > /dev/null 2>&1; then
                echo "‚úÖ Backend Django can be imported"
                backend_ready=true
                break
              else
                echo "‚è≥ Waiting for backend... ($i/30)"
                if [ $i -eq 30 ]; then
                  echo "‚ùå Backend failed to start properly after 90s"
                  echo "üìã Backend container logs:"
                  docker-compose logs --tail=50 backend
                  echo "üìã Backend container status:"
                  docker-compose ps backend
                  echo "üìã Backend environment check:"
                  docker-compose exec -T backend env | grep DJANGO_SETTINGS_MODULE || echo "DJANGO_SETTINGS_MODULE not found"
                  echo "üìã Testing Django configuration:"
                  docker-compose exec -T backend python test_django_config.py 2>&1 || echo "Django config test failed"
                  exit 1
                fi
                sleep 3
              fi
            done
            
            if [ "$backend_ready" = false ]; then
              echo "‚ùå Backend readiness check failed"
              exit 1
            fi
            
            echo "üöÄ Starting all services..."
            
            # Start services with better orchestration
            echo "üì¶ Starting backend and related services first..."
            docker-compose up -d backend celery-worker celery-beat
            
            # Wait for backend to be fully ready
            echo "‚è≥ Waiting for backend to be fully ready..."
            sleep 10
            
            # Start frontend
            echo "üì¶ Starting frontend..."
            docker-compose up -d frontend
            
            # Wait for frontend to start
            echo "‚è≥ Waiting for frontend to start..."
            sleep 10
            
            # Finally start nginx (reverse proxy)
            echo "üì¶ Starting nginx reverse proxy..."
            docker-compose up -d nginx
            
            # Give nginx time to start and configure
            echo "‚è≥ Waiting for nginx to configure..."
            sleep 15
            
            # Verify all services are running
            echo "üìã Verifying all services are running..."
            if ! docker-compose ps | grep -q "Up"; then
              echo "‚ùå Some services failed to start"
              echo "üìã Container status:"
              docker-compose ps
              echo "üìã Recent logs:"
              docker-compose logs --tail=20
              exit 1
            fi
            
            # Optimized health checking with shorter intervals
            echo "‚è≥ Waiting for services to be ready..."
            sleep 15
            
            # Improved health checking with detailed diagnostics
            echo "üè• Testing backend health..."
            backend_healthy=false
            
            for i in {1..15}; do
              # Test different health endpoints
              if curl -f -s -m 5 http://localhost:8000/health/ > /dev/null 2>&1; then
                echo "‚úÖ Backend health endpoint responding"
                backend_healthy=true
                break
              elif curl -f -s -m 5 http://localhost:8000/api/health/ > /dev/null 2>&1; then
                echo "‚úÖ Backend API health endpoint responding"
                backend_healthy=true
                break
              elif curl -s -m 5 http://localhost:8000/ | grep -q "API\|Welcome" 2>/dev/null; then
                echo "‚úÖ Backend root endpoint responding"
                backend_healthy=true
                break
              else
                echo "‚è≥ Backend health check... ($i/15)"
                if [ $i -eq 15 ]; then
                  echo "‚ùå Backend health check failed after 7.5 minutes"
                  echo "üìã Detailed backend diagnostics:"
                  echo "=== Backend container logs (last 50 lines) ==="
                  docker-compose logs --tail=50 backend
                  echo "=== Backend container status ==="
                  docker-compose ps backend
                  echo "=== Backend container processes ==="
                  docker-compose exec -T backend ps aux 2>/dev/null || echo "Could not get process list"
                  echo "=== Network connectivity test ==="
                  docker-compose exec -T backend curl -I localhost:8000 2>/dev/null || echo "Local curl failed"
                  echo "=== Django configuration test ==="
                  docker-compose exec -T backend python manage.py check --deploy 2>&1 || echo "Django check failed"
                  exit 1
                fi
                sleep 30
              fi
            done
            
            if [ "$backend_healthy" = false ]; then
              echo "‚ùå Backend health check failed"
              exit 1
            fi
            
            # Test frontend health with reduced wait time
            echo "üè• Testing frontend health..."
            for i in {1..8}; do
              if curl -f -s http://localhost:3000 > /dev/null 2>&1; then
                echo "‚úÖ Frontend is healthy"
                break
              elif [ $i -eq 8 ]; then
                echo "‚ùå Frontend health check failed"
                echo "üìã Frontend logs:"
                docker-compose logs --tail=30 frontend
                exit 1
              else
                echo "‚è≥ Frontend health check... ($i/8)"
                sleep 10
              fi
            done
            
            # Run initial setup if this is first deployment
            if docker-compose exec -T backend python manage.py showmigrations --plan | grep -q "\[ \]"; then
              echo "üîß Running initial Django setup..."
              if ! docker-compose exec -T backend python manage.py migrate; then
                echo "‚ùå Migration failed. Check database connectivity:"
                echo "   - Verify RDS PostgreSQL is accessible"
                echo "   - Check database credentials in backend/.env"
                docker-compose logs backend
                exit 1
              fi
              docker-compose exec -T backend python manage.py collectstatic --noinput
            fi
            
            # Final health check
            echo "üè• Final health check..."
            
            # Check if all containers are running
            echo "üìã Checking container status..."
            docker-compose ps
            
            # Check if ports are listening
            echo "üìã Checking port availability..."
            if command -v netstat >/dev/null 2>&1; then
              echo "Listening ports:"
              netstat -tlnp | grep -E ':80|:443|:3000|:8000' || echo "No relevant ports found"
            elif command -v ss >/dev/null 2>&1; then
              echo "Listening ports:"
              ss -tlnp | grep -E ':80|:443|:3000|:8000' || echo "No relevant ports found"
            fi
            
            # Test local connectivity
            echo "üìã Testing local connectivity..."
            
            # Test nginx (should be on port 80 and 443)
            if curl -f -s -m 10 http://localhost:80/health > /dev/null 2>&1; then
              echo "‚úÖ Nginx HTTP (port 80) is responding"
            else
              echo "‚ùå Nginx HTTP (port 80) is not responding"
              echo "üìã Nginx container logs:"
              docker-compose logs --tail=20 nginx
            fi
            
            if curl -f -s -m 10 -k https://localhost:443/health > /dev/null 2>&1; then
              echo "‚úÖ Nginx HTTPS (port 443) is responding"
            else
              echo "‚ùå Nginx HTTPS (port 443) is not responding"
              echo "üìã Checking SSL certificate files:"
              ls -la "$APP_DIR/nginx/ssl/" || echo "SSL directory not found"
            fi
            
            # Test backend directly
            if curl -f -s -m 10 http://localhost:8000/health/ > /dev/null 2>&1; then
              echo "‚úÖ Backend (port 8000) is responding"
            else
              echo "‚ùå Backend (port 8000) is not responding"
              echo "üìã Backend container logs:"
              docker-compose logs --tail=20 backend
            fi
            
            # Test frontend directly
            if curl -f -s -m 10 http://localhost:3000 > /dev/null 2>&1; then
              echo "‚úÖ Frontend (port 3000) is responding"
            else
              echo "‚ùå Frontend (port 3000) is not responding"
              echo "üìã Frontend container logs:"
              docker-compose logs --tail=20 frontend
            fi
            
            # Test external connectivity (what Cloudflare sees)
            echo "üìã Testing external connectivity..."
            PUBLIC_IP=$(curl -s -m 10 http://checkip.amazonaws.com/ 2>/dev/null || echo "unknown")
            echo "Server public IP: $PUBLIC_IP"
            
            # Test direct access to the server (bypassing Cloudflare)
            echo "üåê Testing direct server access (bypassing Cloudflare)..."
            
            # Test HTTP directly to public IP
            if [ "$PUBLIC_IP" != "unknown" ] && [ -n "$PUBLIC_IP" ]; then
              echo "Testing HTTP access to $PUBLIC_IP..."
              if curl -f -s -m 10 -H "Host: be-watch-party.brahim-elhouss.me" "http://$PUBLIC_IP/health" > /dev/null 2>&1; then
                echo "‚úÖ Direct HTTP access to $PUBLIC_IP works"
              else
                echo "‚ùå Direct HTTP access to $PUBLIC_IP failed"
                echo "Trying without Host header..."
                if curl -f -s -m 10 "http://$PUBLIC_IP/health" > /dev/null 2>&1; then
                  echo "‚úÖ Direct HTTP access to $PUBLIC_IP works (without Host header)"
                else
                  echo "‚ùå Direct HTTP access to $PUBLIC_IP completely failed"
                fi
              fi
              
              echo "Testing HTTPS access to $PUBLIC_IP..."
              if curl -f -s -m 10 -k -H "Host: be-watch-party.brahim-elhouss.me" "https://$PUBLIC_IP/health" > /dev/null 2>&1; then
                echo "‚úÖ Direct HTTPS access to $PUBLIC_IP works"
              else
                echo "‚ùå Direct HTTPS access to $PUBLIC_IP failed"
                echo "Trying without Host header..."
                if curl -f -s -m 10 -k "https://$PUBLIC_IP/health" > /dev/null 2>&1; then
                  echo "‚úÖ Direct HTTPS access to $PUBLIC_IP works (without Host header)"
                else
                  echo "‚ùå Direct HTTPS access to $PUBLIC_IP completely failed"
                fi
              fi
              
              # Test the actual website content
              echo "Testing full website response..."
              echo "HTTP Response from $PUBLIC_IP:"
              curl -s -m 10 -H "Host: watch-party.brahim-elhouss.me" "http://$PUBLIC_IP/" | head -10 || echo "No HTTP response"
              
              echo "HTTPS Response from $PUBLIC_IP:"
              curl -s -m 10 -k -H "Host: watch-party.brahim-elhouss.me" "https://$PUBLIC_IP/" | head -10 || echo "No HTTPS response"
            else
              echo "‚ùå Could not determine public IP address"
            fi
            
            # Check if firewall is blocking ports
            echo "üìã Checking firewall status..."
            if command -v ufw >/dev/null 2>&1; then
              echo "UFW status:"
              sudo ufw status 2>/dev/null || echo "Cannot check UFW status"
            fi
            
            if command -v iptables >/dev/null 2>&1; then
              echo "Iptables rules for HTTP/HTTPS:"
              sudo iptables -L INPUT -n | grep -E ':80|:443' 2>/dev/null || echo "No specific iptables rules found"
            fi
            
            # Final comprehensive test
            if curl -f http://localhost:8000/health/ > /dev/null 2>&1; then
              echo "üéâ Deployment successful!"
              echo "   Server Public IP: $PUBLIC_IP"
              echo "   Frontend: https://watch-party.brahim-elhouss.me/"
              echo "   Backend API: https://be-watch-party.brahim-elhouss.me/api/"
              echo "   (HTTP requests will be automatically redirected to HTTPS)"
              echo ""
              echo "üîç If you're still getting Cloudflare Error 521:"
              echo "   1. Verify Cloudflare DNS points to: $PUBLIC_IP"
              echo "   2. Check that ports 80 and 443 are open in your firewall"
              echo "   3. Ensure SSL certificates are valid (check above)"
              echo "   4. Wait a few minutes for DNS propagation"
            else
              echo "‚ùå Final health check failed - services may not be accessible externally"
              echo "üìã Container status:"
              docker-compose ps
              echo "üìã All container logs:"
              docker-compose logs --tail=10
              exit 1
            fi
            
            # Cleanup
            docker system prune -f
